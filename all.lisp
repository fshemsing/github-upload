;;;; all: returns a goal whose success is equivalent to the simultaneous
;;;;   success of the goals passed to all. There are two forms of all
;;;;   all and all-i that concatenate and append the substitutions
;;;;   generated by the goals.

;;; all-aux:
(defmacro all-aux (bnd &optional g0 &rest g)
  (cond ((and (null g0)
	      (null g))
	 `#'succ) ; no goals is successful
	((null g)
	 `,g0) ; successful if only goal is successful
	(t (let ((g^ (gensym))
		 (s (gensym)))
	     `(let ((,g^ ,g0))
		(lambda (,s)
		  (funcall ,bnd (funcall ,g^ ,s)
			   (lambda (,s)
			     (funcall (all-aux ,bnd ,@g) ,s)))))))))

;;; all: 
;;;
;;; eg/ if (all a b c) is evaluated on a stream s where each of a b and c are
;;;     goals that each produce a stream of three substitutions from any
;;;     substitution, the following streams will be generated
;;;     (the final stream will be returned)
;;;
;;;    S<as1 as2 as3>
;;;    S<bas11 bas12 bas13 bas21 bas22 bas23 bas33 bas31 bas32 bas33>
;;;    S<cbas111 ... cbas 331,
;;;      cbas112 ... cbas 332,
;;;      cbas113 ... cbas 333>
(defmacro all (&rest g)
  `(all-aux #'bind ,@g))

;;; all-i:
;;;
;;; eg/ if (all a b c) is evaluated on s as in the example for all the
;;;     following streams are generated in the evaluation
;;;
;;;   S<as1 as2 as3>
;;;   S<bas11 bas21 bas31 bas12 bas22 bas32 bas13 bas23 bas33>
;;;   S<cbas111 cbas211 cbas311 ...  cbas113 cbas333>
(defmacro all-i (&rest g)
  `(all-aux #'bind-i ,@g))
